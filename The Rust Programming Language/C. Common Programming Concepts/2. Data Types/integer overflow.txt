# Integer Overflow:

A variable of type u8 can hold values between 0 and 255. If you try to change the variable value outside that range -> 256, integer overflow will occur, which can result in one of the two behaviours.
When you are compiling in debug mode, Rust includes checks for integer overflows that cause your program to panic at runtime if this behaviour occurs.
When you are compiling in release mode, Rust does not include checks for integer overflow that cause panic. Instead if overflow occurs, Rust perform two's complement wrapping.
In short, values greater then the type can hold "wrap around" to the minimum of the values the type can hold.

In case of u8, 256 becomes 0.
The program won't panic, but the variable will have a value that probably isn't what you were expecting to have.
Relying on integer overflow's wrapping is considered an error.

To explicitly handle the possibility of overflow, use these methods provided by the standard library fro primitive numeric types:
1] Wrap in all modes with the wrapping_* methods, such as wrapping_add.
2] Return the "None" value if there is overflow with the checked_* methods.
3] Return a value and a boolean indicating whether there was integer overflow with the voerflowing_* methods.
4] Saturate at the value's minimum or maximum values with the staturating_* methods.